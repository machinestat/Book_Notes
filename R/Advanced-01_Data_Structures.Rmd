---
title: "Data Structures"
output: pdf_document
---

## Introduction

R's base data structures can be organized by their dimensionality (1d, 2d, or nd) and whether they're homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types). This gives rise the five data types most often used in data analysis:

|    | Homogeneous     |  Heterogeneous  |
|----|:----------------|:----------------|
| 1d | Atomic vector   | List            |
| 2d | Matrix          | Data frame      |
| nd | Array

Almost all other objects are built upon these foundations. Note that R has no 0-dimentional, or scalar types. Individual numbers or strings are actually vectors of length one. Given an object, the best way to understand what data structures it's composed of is to use `str()`.

## 1.1 vectors
The basic data structure in R is the vector. There are two kinds of vectors: atomic vectors and lists. They have three common properties:   
* Type, typeof(), what it is.
* Length, length(), how many elements it contains.
* Attributes, attributes(), additional arbitrary metadata.

They differ in the types of their elements: all elements of an atomic vector must be the same type, whereas the elements of a list can have different types. Use `is.vector() || is.list()` to test if an object actually a vector.

## 1.1.1 Atomic Vector
There are four common types of atomic vectors: logical, integer, double(often called numeric), and character.

Create atomic vectors with `c()`:
```{r}
dbl_var <- c(1, 2.5, 4.5)
int_var <- c(1L, 6L, 10L)# get an integer vector with L suffix
log_var <- c(TRUE, FALSE, T, F) # use TRUE, FALSE(or T, F) to create logical vector
chr_var <- c("these are", "some strings")

#Atomic vectors are always flat
c(1, c(2, c(3, 4)))
```

### 1.1.1.1 Types and tests
We can determine a vector's type with `typeof()`, or check if it is a specific type with an "is" function: `is.character()`, `is.double()`, `is.integer()`, `is.logical()`, or `is.atomic()`.

```{r}
typeof(int_var)
is.integer(int_var)
is.atomic(int_var)

typeof(dbl_var)
is.double(dbl_var)
is.atomic(dbl_var)
```

`is.numeric` is a general test and return *TRUE* for both integer and double vectors.

### 1.1.1.2 Coercion
If we combine two types of vectors they will be *coerced* to the most flexible type. Types from least to most flexible are: logical, integer, double and character. When a logical vector is coerced to an integer or double, *TRUE* becomes 1 and *FALSE* becomes 0. For example, combining a character and an integer yields a character:
```{r}
str(c("a", 1))
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)

# Total number of TRUEs
sum(x)

# Proportion that are TRUE
mean(x)
```
## 1.1.2 Lists
The elements in a list can be any type, including lists, and we can construct lists using *list()*

```{r}
x <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
str(x)
```
Lists are sometimes called *recursive* vectors, because a list can contain other lists.
```{r}
x <- list(list(list(list())))
str(x)
is.recursive(x)
# if given a combination of atomic vectors and lists, c() will #coerce the vector to list before combining them.
x <- list(list(1, 2), c(3, 4))
y <- c(list(1, 2), c(3, 4))
str(x)
str(y)
```
*typeof()* a list is list, test for a list with *is.list()*, coerce to a list with *as.list()*, turn a list into an atomic vector with *unlist()* using the same coersion rules as *c()*.

Lists are used to build up many of the more complicated data structures in R. For example, both data frames and linear models objects (as produced by *lm()*) are lists:
```{r}
is.list(mtcars)

mod <- lm(mpg ~ wt, data = mtcars)
is.list(mod)
```

# 1.1.3 Exercises

  1. What are the six types of atomic vector? How does a list differ from an atomic vector?

Answer: The six types of atomic vector are:

 * logical (may contain TRUE, FALSE, NA)
 * integer
 * double (often called numeric)
 * complex
 * character
 * raw
    
  2. What makes *is.vector()* and *is.numeric()* fundamentally different to *is.list()* and *is.character()*?

Answer: 

 * *is.vector* does not test if an object is a vector, it returns *TRUE* only if a vector has no other attributes than names. we can use *is.atomic() || is.list()* to test if an object is a vector.
 * *is.numeric()* returns *TRUE* for both integer and double vectors.
 * both *is.list()* and *is.character()* are for testing if an object is a list or character vector.
 
 3. Predict the output of the following uses of c() according to vector coercion rules.
 
 c(1, FALSE)  
 c("a", 1)  
 c(list(1), "a")  
 c(TRUE, 1L)  
 
Answer: The coercion rules are two different types elements will be *coerced* to the most flexible type. Types from least to most flexible are: logical, integer, double and character. So,

 * c(1, FALSE) -> double  
 * c("a", 1) -> character  
 * c(list(1), "a") -> list  
 * c(TRUE, 1L) -> integer  

 4. Why do you need to use *unlist()* to convert a list to an atomic
vector? Why doesnâ€™t *as.vector()* work?

Answer: a list actually is a vector, so if we use *as.vector()* on a list we get the list itself, so we need to use *unlist()* to convert a list to an atomic vector.

 5. Why is 1 == "1" true? Why is -1 < FALSE true? Why is "one"
< 2 false?

Answer: when doing the comparison, 1 automatically coerced to "1", so "1" == "1". Similarly, FALSE coerced to 0 and compared to -1. Finally, 2 coerced to character before compare to "one", so now we compare two characters like sorting and we actually compare "2" and "o". Charcters are translated to UTF-8 before comparison, in UTF-8 coding "2" is 50 and "o" is "111", so "one" is greater than 2.



