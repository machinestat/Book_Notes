---
title: "Data Structures"
output: pdf_document
---

## Introduction

R's base data structures can be organized by their dimensionality (1d, 2d, or nd) and whether they're homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types). This gives rise the five data types most often used in data analysis:

|    | Homogeneous     |  Heterogeneous  |
|----|:----------------|:----------------|
| 1d | Atomic vector   | List            |
| 2d | Matrix          | Data frame      |
| nd | Array

Almost all other objects are built upon these foundations. Note that R has no 0-dimentional, or scalar types. Individual numbers or strings are actually vectors of length one. Given an object, the best way to understand what data structures it's composed of is to use `str()`.

## 1.1 Vectors
The basic data structure in R is the vector. There are two kinds of vectors: atomic vectors and lists. They have three common properties:   
* Type, typeof(), what it is.
* Length, length(), how many elements it contains.
* Attributes, attributes(), additional arbitrary metadata.

They differ in the types of their elements: all elements of an atomic vector must be the same type, whereas the elements of a list can have different types. Use `is.vector() || is.list()` to test if an object actually a vector.

## 1.1.1 Atomic Vector
There are four common types of atomic vectors: logical, integer, double(often called numeric), and character.

Create atomic vectors with `c()`:
```{r}
dbl_var <- c(1, 2.5, 4.5)
int_var <- c(1L, 6L, 10L)# get an integer vector with L suffix
log_var <- c(TRUE, FALSE, T, F) # use TRUE, FALSE(or T, F) to create logical vector
chr_var <- c("these are", "some strings")

#Atomic vectors are always flat
c(1, c(2, c(3, 4)))
```

### 1.1.1.1 Types and tests
We can determine a vector's type with `typeof()`, or check if it is a specific type with an "is" function: `is.character()`, `is.double()`, `is.integer()`, `is.logical()`, or `is.atomic()`.

```{r}
typeof(int_var)
is.integer(int_var)
is.atomic(int_var)

typeof(dbl_var)
is.double(dbl_var)
is.atomic(dbl_var)
```

`is.numeric` is a general test and return *TRUE* for both integer and double vectors.

### 1.1.1.2 Coercion
If we combine two types of vectors they will be *coerced* to the most flexible type. Types from least to most flexible are: logical, integer, double and character. When a logical vector is coerced to an integer or double, *TRUE* becomes 1 and *FALSE* becomes 0. For example, combining a character and an integer yields a character:
```{r}
str(c("a", 1))
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)

# Total number of TRUEs
sum(x)

# Proportion that are TRUE
mean(x)
```
## 1.1.2 Lists
The elements in a list can be any type, including lists, and we can construct lists using `list()`

```{r}
x <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
str(x)
```
Lists are sometimes called *recursive* vectors, because a list can contain other lists.
```{r}
x <- list(list(list(list())))
str(x)
is.recursive(x)
# if given a combination of atomic vectors and lists, c() will #coerce the vector to list before combining them.
x <- list(list(1, 2), c(3, 4))
y <- c(list(1, 2), c(3, 4))
str(x)
str(y)
```
`typeof()` a list is list, test for a list with `is.list()`, coerce to a list with `as.list()`, turn a list into an atomic vector with `unlist()` using the same coersion rules as `c()`.

Lists are used to build up many of the more complicated data structures in R. For example, both data frames and linear models objects (as produced by `lm()`) are lists:
```{r}
is.list(mtcars)

mod <- lm(mpg ~ wt, data = mtcars)
is.list(mod)
```

## 1.1.3 Exercises

1. What are the six types of atomic vector? How does a list differ from an atomic vector?

Answer: The six types of atomic vector are:

 * logical (may contain TRUE, FALSE, NA)
 * integer
 * double (often called numeric)
 * complex
 * character
 * raw
    
2. What makes `is.vector()` and `is.numeric()` fundamentally different to `is.list()` and `is.character()`?

Answer: 

 (1) `is.vector` does not test if an object is a vector, it returns *TRUE* only if a vector has no other attributes than names. we can use `is.atomic() || is.list()` to test if an object is a vector.
 (2) `is.numeric()` returns *TRUE* for both integer and double vectors.
 (3) `is.list()` and `is.character()` are for testing if an object is a list or character vector.
 
3. Predict the output of the following uses of c() according to vector coercion rules.
 
 c(1, FALSE)  
 c("a", 1)  
 c(list(1), "a")  
 c(TRUE, 1L)  
 
Answer: The coercion rules are two different types elements will be *coerced* to the most flexible type. Types from least to most flexible are: logical, integer, double and character. So,

 * c(1, FALSE) -> double  
 * c("a", 1) -> character  
 * c(list(1), "a") -> list  
 * c(TRUE, 1L) -> integer  

4. Why do you need to use `unlist()` to convert a list to an atomic vector? Why doee't `as.vector()` work?

Answer: a list actually is a vector, so if we use `as.vector()` on a list we get the list itself, so we need to use `unlist()` to convert a list to an atomic vector.

5. Why is 1 == "1" true? Why is -1 < FALSE true? Why is "one" < 2 false?

Answer: when doing the comparison, 1 automatically coerced to "1", so "1" == "1". Similarly, FALSE coerced to 0 and compared to -1. Finally, 2 coerced to character before compare to "one", so now we compare two characters like sorting and we actually compare "2" and "o". Charcters are translated to UTF-8 before comparison, in UTF-8 coding "2" is 50 and "o" is "111", so "one" is greater than 2.

6. Why is the default missing value, NA, a logical vector? What's special about logical vectors? 

Missing values are specified with NA, which is a logical vector of length
1. NA will always be coerced to the correct type if used inside c(), or
we can create NAs of a specific type with `NA_real_` (a double vector), `NA_integer_` and `NA_character_`.

## 1.2 Attributes

All objects can have arbitrary additional attributes, used to store metadata about the object. Attributes can be thought of a list of unique names. Attributes can be accessed individually with `attr()` or all at once as a list with `attributes()`.

```{r}
y <- 1:10
attr(y, "my_attribute") <- "This is a vector"
attr(y, "my_attribute")
str(attributes(y))
```

The `structure()` function returns a new object with modified attributes: 
```{r}
structure(1:10, my_attribute = "This is a vector")
```

By default, most attributes are lost when modifying a vector:
```{r}
attributes(y[1])
attributes(sum(y))
```

The only attributes not lost are three most important:

 * Names, a character vector giving each element a name.
 * Dimensions, used to turn vectors into matrices and arrays.
 * Class, used to implement the S3 object system.
 
Each of these attributes has a specific accessor function to get and set values: `names(x)`, `class(x)`, and `dim(x)`. 
