---
title: "Subsetting"
output: html_document
---

## 2.1 Data types

It’s easiest to learn how subsetting works for atomic vectors, and then how it generalises to higher dimensions and other more complicated objects.

### 2.1.1 Atomic vectors

explore the different types of subsetting with a simple vector, x

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
# the number after the decimal point gives the original position in the vector.

# Positive integers return elements at the specified positions:
x[c(3, 1)]
x[order(x)]
#  Duplicated indices yield duplicated values
x[c(1, 1)]
# Real numbers are silently truncated to integers
x[c(2.1, 2.9)]

# Negative integers omit elements at the specified positions:
x[-c(3, 1)]
# Cannot mix positive and negative integers in a single subset:
# x[c(-1, 2)]
# Error in x[c(-1, 2)] : only 0's may be mixed with negative subscripts

#  Logical vectors select elements where the corresponding logical value is TRUE.
x[c(TRUE, TRUE, FALSE, FALSE)]
x[x > 3]
# A missing value in the index always yields a missing value in the output:
x[c(TRUE, TRUE, NA, FALSE)]


# Nothing returns the original vector.
x[]

# • Zero returns a zero-length vector.
x[0]

# Use character vectors to return elements with matching names  when the vector is named
(y <- setNames(x, letters[1:4]))
y[c("d", "c", "a")]
```

### 2.1.2 Lists

Subsetting a list works in the same way as subsetting an atomic vector.

### 2.1.3 Matrices and arrays

Subset higher-dimensional structures in three ways:

* With multiple vectors.
* With a single vector.
* With a matrix.

```{r}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")
a[1:2, ]
a[c(T, F, T), c("B", "A")]

# Because matrices and arrays are implemented as vectors with special attributes, you can subset them with a single vector. In that case, they will behave like a vector. Arrays in R are stored in column-major order
(vals <- outer(1:5, 1:5, FUN = "paste", sep = ","))
vals[c(4, 15)] 

# Subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value, where each column corresponds to a dimension in the array being subsetted.
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
select <- matrix(ncol = 2, byrow = TRUE, c( 1, 1,
                                            3, 1,
                                            2, 4
                                            ))
vals[select]
```

### 2.1.4 Data frames

Data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df[df$x == 2, ]
df[c(1, 3), ]

# There are two ways to select columns from a data frame
# Like a list:
df[c("x", "z")]
# Like a matrix
df[, c("x", "z")]

# There's an important difference if you select a single
# column: matrix subsetting simplifies by default, list
# subsetting does not.
str(df["x"])
str(df[, "x"])
```

### 2.1.5 S3 objects

S3 objects are made up of atomic vectors, arrays, and lists, so you can always pull apart an S3 object using the techniques described above and the knowledge you gain from `str()`.

### 2.1.6 S4 objects
There are also two additional subsetting operators that are needed for S4 objects: @ (equivalent to $), and slot() (equivalent to [[). @ is more restrictive than $ in that it will return an error if the slot does not exist.

### 2.1.7 Exercises

1. Fix each of the following common data frame subsetting errors:
    mtcars[mtcars$cyl = 4, ] 
    mtcars[-1:4, ] 
    mtcars[mtcars$cyl <= 5]
    mtcars[mtcars$cyl == 4 | 6, ]
    
    ```{r}
        mtcars[mtcars$cyl == 4, ]
        mtcars[-c(1:4), ]
        mtcars[mtcars$cyl <= 5, ]
        mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]
    ```
    
2. Why does x <- 1:5; x[NA] yield five missing values?
    The rules for logical indices applies in this case, and it recycles since it is shorter than the elements(which is 5) in x, so the results are five elements as in original x. Since a missing value in the index always yields a missing value in the output they are NAs. NA_real is a constant missing value when using as x[NA_real_] so it will result a single NA.

3. What does `upper.tri()` return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?
    x <- outer(1:5, 1:5, FUN = "*")
    x[upper.tri(x)]

    `upper.tri()` returns a matrix of logicals the same size of a given matrix with entries TRUE in the lower or upper triangle.

4. Why does mtcars[1:20] return a error? How does it differ from the similar mtcars[1:20, ]?
    we need to specify both row and column indeces for a data frame.
    
5. Implement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix).

6. What does df[is.na(df)] <- 0 do? How does it work?
    Change the missing values in df to 0s.
    
## 2.2 Subsetting operators

There are two other subsetting operators: [[ and $. [[ is similar to [, except it can only return a single value and it allows you to pull pieces out of a list. $ is a useful shorthand for [[ combined with character subsetting. When [ is applied to a list it always returns a list, use [[ to get the contents of a list.

    “If list x is a train carrying objects, then x[[5]] is the object in car 5; x[4:6] is a train of cars 4-6.” — @RLangTip
    
```{r}
# must use [[ with either a single positive integer or a string:
a <- list(a = 1, b = 2)
a[[1]]
a[["a"]]

# If you do supply a vector it indexes recursively
b <- list(a = list(b = list(c = list(d = 1))))
b[[c("a", "b", "c", "d")]]
b[["a"]][["b"]][["c"]][["d"]]
```

### 2.2.1 Simplifying vs. preserving subsetting

Simplifying subsets returns the simplest possible data structure that can represent the output, and is useful interactively because it usually gives you what you want. Preserving subsetting keeps the structure of the output the same as the input, and is generally better for programming because the result will always be the same type. Omitting `drop = FALSE` when subsetting matrices and data frames is one of the most common sources of programming errors. 

|          | Simplifying       | Preserving            |
|----------|-------------------|-----------------------|
| Vector   | x[[1]]            | x[1]                  |
| List     | x[[1]]            | x[1]                  |
| Factor   | x[1:4, drop = T]  | x[1:4]                |
| Array    | x[1, ] or x[, 1]  | x[1, , drop = F] or x[, 1, drop = F] |
| Data frame | x[, 1] or x[[1]] | x[, 1, drop = F] or x[1] |

Preserving is the same for all data types: you get the same type of output as input. Simplifying behaviour varies slightly between different data types, as described below:

* Atomic vector: removes names.
```{r}
  x <- c(a = 1, b = 2)
  x[1]
  x[[1]]
```

* List: return the object inside the list, not a single element list.
```{r}
y <- list(a = 1, b = 2)
str(y[1])
str(y[[1]])
```

* Factor: drops any unused levels.
```{r}
z <- factor(c("a", "b"))
z[1]
z[1, drop = TRUE]
```

* Matrix or array: if any of the dimensions has length 1, drops that dimension.
```{r}
a <- matrix(1:4, nrow = 2)
a[1, , drop = FALSE]
a[1, ]
```

* Data frame: if output is a single column, returns a vector instead of a data frame.
```{r}
df <- data.frame(a = 1:2, b = 1:2)
str(df[1])
str(df[[1]])
str(df[, "a", drop = FALSE])
str(df[, "a"])
```

### 2.2.2 `$`

`$` is a shorthand operator, where `x$y` is equivalent to `x[["y", exact = FALSE]]`. It’s often used to access variables in a data frame, as in `mtcars$cyl` or `diamonds$carat`.

One common mistake with `$` is to try and use it when you have the name of a column stored in a variable:
```{r}
var <- "cyl"
# Doesn't work - mtcars$var translated to mtcars[["var"]]
mtcars$var

# Instead use [[
mtcars[[var]]
```

There’s one important difference between $ and [[. $ does partial matching:
```{r}
x <- list(abc = 1)
x$a
#> [1] 1
x[["a"]]
#> NULL
```

### 2.2.3 Missing/out of bounds indices

[ and [[ differ slightly in their behaviour when the index is out of bounds (OOB)
```{r}
x <- 1:4
str(x[5])
str(x[NA_real_])
str(x[NULL])
```

The following table summarises the results of subsetting atomic vectors and lists with [ and [[ and different types of OOB value.

| Operator   | Index    |  Atomic   | List         |
|------------|----------|-----------|--------------|
| [          | OOB      | NA        | list(NULL)   |
| [          | NA_real_ | NA        | list(NULL)   |
| [          | NULL     | x[0]      | list(NULL)   |
| [[         | OOB      | Error     | Error        |
| [[         | NA_real_ | Error     | NULL         |
| [[         | NULL     | Error     | Error        |

### 2.2.4 Exercises
1. Given a linear model, e.g., mod <- lm(mpg ~ wt, data = mtcars), extract the residual degrees of freedom. Extract the R squared from the model summary (summary(mod))
```{r}
mod <- lm(mpg ~ wt, data = mtcars)
mod$df.residual
summary(mod)$r.squared
```

## 2.3 Subsetting and assignment

All subsetting operators can be combined with assignment to modify selected values of the input vector.

```{r}
x <- 1:5
x[c(1, 2)] <- 2:3
x

# The length of the LHS needs to match the RHS
x[-1] <- 4:1

# Note that there's no checking for duplicate indices
x[c(1, 1)] <- 2:3

# You can't combine integer indices with NA
x[c(1, NA)] <- c(1, 2)

# But you can combine logical indices with NA
# (where they're treated as false).
x[c(T, F, NA)] <- 1

# This is mostly useful when conditionally modifying vectors
df <- data.frame(a = c(1, 10, NA))
df$a[df$a < 5] <- 0
df$a
```

Subsetting with nothing can be useful in conjunction with assignment
because it will preserve the original object class and structure. Compare the following two expressions. In the first, mtcars will remain as a data frame. In the second, mtcars will become a list.

```{r}
mtcars[] <- lapply(mtcars, as.integer)
mtcars <- lapply(mtcars, as.integer)
```

Use subsetting + assignment + NULL to remove components from a list. To add a literal NULL to a list, use [ and list(NULL):
```{r}
x <- list(a = 1, b = 2)
x[["b"]] <- NULL
str(x)

y <- list(a = 1)
y["b"] <- list(NULL)
str(y)
```

## 2.4 Applications

### 2.4.1 Lookup tables (character subsetting)

Character matching provides a powerful way to make lookup tables.
```{r}
# want to convert abbreviations
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
unname(lookup[x]) # use unname() to remove names in the result

# Or with fewer output values
c(m = "Known", f = "Known", u = "Unknown")[x]
```
